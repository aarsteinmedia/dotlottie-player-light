{
  "schemaVersion": "1.0.0",
  "readme": "",
  "modules": [
    {
      "kind": "javascript-module",
      "path": "dist/index.js",
      "declarations": [
        {
          "kind": "variable",
          "name": "tV"
        }
      ],
      "exports": [
        {
          "kind": "custom-element-definition",
          "name": "dotlottie-player",
          "declaration": {
            "name": "tV",
            "module": "dist/index.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "dist/cjs/index.js",
      "declarations": [
        {
          "kind": "variable",
          "name": "DotLottiePlayer",
          "default": "class DotLottiePlayer extends EnhancedElement { async connectedCallback() { super.connectedCallback(); this._render(); this._container = this.shadow.querySelector('.animation'); this._renderControls(); if (typeof document.hidden !== 'undefined') { document.addEventListener('visibilitychange', this._onVisibilityChange); } this._addIntersectionObserver(); await this.load(this.src); this.dispatchEvent(new CustomEvent(PlayerEvents.Rendered)); } disconnectedCallback() { if (this._intersectionObserver) { this._intersectionObserver.disconnect(); this._intersectionObserver = undefined; } if (this._lottieInstance) { this._lottieInstance.destroy(); } document.removeEventListener('visibilitychange', this._onVisibilityChange); } static get observedAttributes() { return [ 'animateOnScroll', 'autoplay', 'controls', 'direction', 'hover', 'loop', 'mode', 'speed', 'subframe' ]; } attributeChangedCallback(name, _oldValue, value) { if (!this._lottieInstance) { return; } if (name === 'animateOnScroll') { if (value === '' || Boolean(value)) { this._lottieInstance.autoplay = false; addEventListener('scroll', this._handleScroll, { capture: true, passive: true }); return; } removeEventListener('scroll', this._handleScroll, true); } if (name === 'autoplay') { if (this.animateOnScroll) { return; } if (value === '' || Boolean(value)) { this.play(); return; } this.stop(); } if (name === 'controls') { this._renderControls(); } if (name === 'direction') { if (Number(value) === -1) { return this.setDirection(-1); } this.setDirection(1); } if (name === 'hover' && this._container) { if (value === '' || Boolean(value)) { this._container.addEventListener('mouseenter', this._mouseEnter); this._container.addEventListener('mouseleave', this._mouseLeave); return; } this._container.removeEventListener('mouseenter', this._mouseEnter); this._container.removeEventListener('mouseleave', this._mouseLeave); } if (name === 'loop') { const toggleLoop = this.shadow.querySelector('.toggleLoop'); if (toggleLoop instanceof HTMLButtonElement) { toggleLoop.dataset.active = value; } this.setLoop(value === '' || Boolean(value)); } if (name === 'mode') { const toggleBoomerang = this.shadow.querySelector('.toggleBoomerang'); if (toggleBoomerang instanceof HTMLButtonElement) { toggleBoomerang.dataset.active = (value === PlayMode.Bounce).toString(); } this._isBounce = value === PlayMode.Bounce; } if (name === 'speed') { const val = Number(value); if (val && !isNaN(val)) { this.setSpeed(val); } } if (name === 'subframe') { this.setSubframe(value === '' || Boolean(value)); } } static get observedProperties() { return [ 'playerState', '_isSettingsOpen', '_seeker', '_currentAnimation', '_animations' ]; } propertyChangedCallback(name, _oldValue, value) { if (!this.shadow) { return; } const togglePlay = this.shadow.querySelector('.togglePlay'), stop = this.shadow.querySelector('.stop'), prev = this.shadow.querySelector('.prev'), next = this.shadow.querySelector('.next'), seeker = this.shadow.querySelector('.seeker'), progress = this.shadow.querySelector('progress'), popover = this.shadow.querySelector('.popover'); if (!(togglePlay instanceof HTMLButtonElement) || !(stop instanceof HTMLButtonElement) || !(next instanceof HTMLButtonElement) || !(prev instanceof HTMLButtonElement) || !(seeker instanceof HTMLInputElement) || !(progress instanceof HTMLProgressElement)) { return; } if (name === 'playerState') { togglePlay.dataset.active = (value === PlayerState.Playing || value === PlayerState.Paused).toString(); stop.dataset.active = (value === PlayerState.Stopped).toString(); if (value === PlayerState.Playing) { togglePlay.innerHTML = `<svg width=\"24\" height=\"24\" aria-hidden=\"true\" focusable=\"false\"><path d=\"M14.016 5.016H18v13.969h-3.984V5.016zM6 18.984V5.015h3.984v13.969H6z\"/></svg>`; } else { togglePlay.innerHTML = `<svg width=\"24\" height=\"24\" aria-hidden=\"true\" focusable=\"false\"><path d=\"M8.016 5.016L18.985 12 8.016 18.984V5.015z\"/></svg>`; } } if (name === '_seeker' && typeof value === 'number') { seeker.value = value.toString(); seeker.ariaValueNow = value.toString(); progress.value = value; } if (name === '_animations' && Array.isArray(value)) { if (this._currentAnimation + 1 < value.length) { next.hidden = false; } } if (name === '_currentAnimation' && typeof value === 'number') { if (value + 1 >= this._animations.length) { next.hidden = true; } else { next.hidden = false; } if (value) { prev.hidden = false; } else { prev.hidden = true; } } if (name === '_isSettingsOpen' && typeof value === 'boolean' && popover instanceof HTMLDivElement) { popover.hidden = !value; } } set animateOnScroll(value) { this.setAttribute('animateOnScroll', (!!value).toString()); } get animateOnScroll() { const val = this.getAttribute('animateOnScroll'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set autoplay(value) { this.setAttribute('autoplay', (!!value).toString()); } get autoplay() { const val = this.getAttribute('autoplay'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set background(value) { this.setAttribute('background', value); } get background() { return this.getAttribute('background') || 'transparent'; } set controls(value) { this.setAttribute('controls', (!!value).toString()); } get controls() { const val = this.getAttribute('controls'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set count(value) { this.setAttribute('count', value.toString()); } get count() { const val = this.getAttribute('count'); if (val) { return Number(val); } return 0; } set description(value) { this.setAttribute('description', value); } get description() { return this.getAttribute('description') || ''; } set direction(value) { this.setAttribute('direction', value.toString()); } get direction() { const val = Number(this.getAttribute('')); if (val === -1) { return val; } return 1; } set hover(value) { this.setAttribute('hover', value.toString()); } get hover() { const val = this.getAttribute('hover'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set intermission(value) { this.setAttribute('intermission', value.toString()); } get intermission() { const val = Number(this.getAttribute('intermission')); if (!isNaN(val)) { return val; } return 0; } set loop(value) { this.setAttribute('loop', (!!value).toString()); } get loop() { const val = this.getAttribute('loop'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set mode(value) { this.setAttribute('mode', value.toString()); } get mode() { const val = this.getAttribute('mode'); if (val === PlayMode.Bounce) { return val; } return PlayMode.Normal; } set multiAnimationSettings(value) { this.setAttribute('multiAnimationSettings', JSON.stringify(value)); } get multiAnimationSettings() { const val = JSON.parse(this.getAttribute('multiAnimationSettings') || 'null'); if (Array.isArray(val)) { return val; } return []; } set objectfit(value) { this.setAttribute('objectfit', value); } get objectfit() { const val = this.getAttribute('objectfit'); if (val && Object.values(ObjectFit).includes(val)) { return val; } return ObjectFit.Contain; } set preserveAspectRatio(value) { this.setAttribute('preserveAspectRatio', value || PreserveAspectRatio.Contain); } get preserveAspectRatio() { const val = this.getAttribute('preserveAspectRatio'); if (val && Object.values(PreserveAspectRatio).includes(val)) { return val; } return null; } set segment(value) { this.setAttribute('segment', JSON.stringify(value)); } get segment() { const val = JSON.parse(this.getAttribute('segment') || 'null'); if (Array.isArray(val)) { return val; } return undefined; } set simple(value) { this.setAttribute('simple', value.toString()); } get simple() { const val = this.getAttribute('simple'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set speed(value) { this.setAttribute('speed', value?.toString()); } get speed() { const val = this.getAttribute('speed'); if (val !== null && !isNaN(Number(val))) { return Number(val); } return 1; } set src(value) { this.setAttribute('src', value || ''); } get src() { return this.getAttribute('src'); } set subframe(value) { this.setAttribute('subframe', (!!value).toString()); } get subframe() { const val = this.getAttribute('subframe'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } _getOptions() { if (!this._container) { throw new Error('Container not rendered'); } const preserveAspectRatio = this.preserveAspectRatio ?? (this.objectfit && aspectRatio(this.objectfit)), currentAnimationSettings = this.multiAnimationSettings?.length ? this.multiAnimationSettings?.[this._currentAnimation] : undefined, currentAnimationManifest = this._manifest.animations?.[this._currentAnimation]; let loop = !!this.loop; if (currentAnimationManifest.loop !== undefined && this.loop === undefined) { loop = !!currentAnimationManifest.loop; } if (currentAnimationSettings?.loop !== undefined) { loop = !!currentAnimationSettings.loop; } let autoplay = !!this.autoplay; if (currentAnimationManifest.autoplay !== undefined && this.autoplay === undefined) { autoplay = !!currentAnimationManifest.autoplay; } if (currentAnimationSettings?.autoplay !== undefined) { autoplay = !!currentAnimationSettings.autoplay; } if (this.animateOnScroll) { autoplay = false; } let initialSegment = this.segment; if (this.segment?.every((val)=>val > 0)) { initialSegment = [ this.segment[0] - 1, this.segment[1] - 1 ]; } if (this.segment?.some((val)=>val < 0)) { initialSegment = undefined; } const options = { autoplay, container: this._container, initialSegment, loop, renderer: 'svg', rendererSettings: { hideOnTransparent: true, imagePreserveAspectRatio: preserveAspectRatio, preserveAspectRatio, progressiveLoad: true } }; return options; } _addIntersectionObserver() { if (!this._container || this._intersectionObserver || !('IntersectionObserver' in window)) { return; } this._intersectionObserver = new IntersectionObserver((entries)=>{ for (const entry of entries){ if (!entry.isIntersecting || document.hidden) { if (this.playerState === PlayerState.Playing) { this._freeze(); } this._playerState.visible = false; continue; } if (!this.animateOnScroll && this.playerState === PlayerState.Frozen) { this.play(); } if (!this._playerState.scrollY) { this._playerState.scrollY = scrollY; } this._playerState.visible = true; } }); this._intersectionObserver.observe(this._container); } async load(src) { if (!this.shadowRoot || !src) { return; } try { const { animations, manifest } = await getAnimationData(src); if (!animations || animations.some((animation)=>!this._isLottie(animation))) { throw new Error('Broken or corrupted file'); } this._isBounce = this.mode === PlayMode.Bounce; if (this.multiAnimationSettings?.length) { if (this.multiAnimationSettings[this._currentAnimation]?.mode) { this._isBounce = this.multiAnimationSettings[this._currentAnimation].mode === PlayMode.Bounce; } } this._animations = animations; this._manifest = manifest ?? { animations: [ { autoplay: !this.animateOnScroll && this.autoplay, direction: this.direction, id: useId(), loop: this.loop, mode: this.mode, speed: this.speed } ] }; if (this._lottieInstance) { this._lottieInstance.destroy(); } this.playerState = PlayerState.Stopped; if (!this.animateOnScroll && (this.autoplay || this.multiAnimationSettings?.[this._currentAnimation]?.autoplay)) { this.playerState = PlayerState.Playing; } this._lottieInstance = Lottie__namespace.default.loadAnimation({ ...this._getOptions(), animationData: animations[this._currentAnimation] }); } catch (err) { this._errorMessage = handleErrors(err).message; this.playerState = PlayerState.Error; this.dispatchEvent(new CustomEvent(PlayerEvents.Error)); return; } this._addEventListeners(); const speed = this.multiAnimationSettings?.[this._currentAnimation]?.speed ?? this.speed ?? this._manifest.animations[this._currentAnimation].speed, direction = this.multiAnimationSettings?.[this._currentAnimation]?.direction ?? this.direction ?? this._manifest.animations[this._currentAnimation].direction ?? 1; this._lottieInstance.setSpeed(speed); this._lottieInstance.setDirection(direction); this._lottieInstance.setSubframe(!!this.subframe); if (this.autoplay || this.animateOnScroll) { if (this.direction === -1) { this.seek('99%'); } if (!('IntersectionObserver' in window)) { if (!this.animateOnScroll) { this.play(); } this._playerState.visible = true; } this._addIntersectionObserver(); } } getManifest() { return this._manifest; } _toggleEventListeners(action) { const method = action === 'add' ? 'addEventListener' : 'removeEventListener'; if (this._lottieInstance) { this._lottieInstance[method]('enterFrame', this._enterFrame); this._lottieInstance[method]('complete', this._complete); this._lottieInstance[method]('loopComplete', this._loopComplete); this._lottieInstance[method]('DOMLoaded', this._DOMLoaded); this._lottieInstance[method]('data_ready', this._dataReady); this._lottieInstance[method]('data_failed', this._dataFailed); } if (this._container && this.hover) { this._container[method]('mouseenter', this._mouseEnter); this._container[method]('mouseleave', this._mouseLeave); } window[method]('focus', this._handleWindowBlur, { capture: false, passive: true }); window[method]('blur', this._handleWindowBlur, { capture: false, passive: true }); if (this.animateOnScroll) { window[method]('scroll', this._handleScroll, { capture: true, passive: true }); } } _addEventListeners() { this._toggleEventListeners('add'); } _removeEventListeners() { this._toggleEventListeners('remove'); } _loopComplete() { if (!this._lottieInstance) { return; } const { playDirection, totalFrames } = this._lottieInstance, inPoint = this.segment ? this.segment[0] : 0, outPoint = this.segment ? this.segment[0] : totalFrames; if (this.count) { if (this._isBounce) { this._playerState.count += 0.5; } else { this._playerState.count += 1; } if (this._playerState.count >= this.count) { this.setLoop(false); this.playerState = PlayerState.Completed; this.dispatchEvent(new CustomEvent(PlayerEvents.Complete)); return; } } this.dispatchEvent(new CustomEvent(PlayerEvents.Loop)); if (this._isBounce) { this._lottieInstance.goToAndStop(playDirection === -1 ? inPoint : outPoint * 0.99, true); this._lottieInstance.setDirection(playDirection * -1); return setTimeout(()=>{ if (!this.animateOnScroll) { this._lottieInstance?.play(); } }, this.intermission); } this._lottieInstance.goToAndStop(playDirection === -1 ? outPoint * 0.99 : inPoint, true); return setTimeout(()=>{ if (!this.animateOnScroll) { this._lottieInstance?.play(); } }, this.intermission); } _enterFrame() { if (!this._lottieInstance) { return; } const { currentFrame, totalFrames } = this._lottieInstance; this._seeker = Math.round(currentFrame / totalFrames * 100); this.dispatchEvent(new CustomEvent(PlayerEvents.Frame, { detail: { frame: currentFrame, seeker: this._seeker } })); } _complete() { if (!this._lottieInstance) { return; } if (this._animations.length > 1) { if (this.multiAnimationSettings?.[this._currentAnimation + 1]?.autoplay) { return this.next(); } if (this.loop && this._currentAnimation === this._animations.length - 1) { this._currentAnimation = 0; return this._switchInstance(); } } const { currentFrame, totalFrames } = this._lottieInstance; this._seeker = Math.round(currentFrame / totalFrames * 100); this.playerState = PlayerState.Completed; this.dispatchEvent(new CustomEvent(PlayerEvents.Complete, { detail: { frame: currentFrame, seeker: this._seeker } })); } _DOMLoaded() { this._playerState.loaded = true; this.dispatchEvent(new CustomEvent(PlayerEvents.Ready)); } _dataReady() { this.dispatchEvent(new CustomEvent(PlayerEvents.Load)); } _dataFailed() { this.playerState = PlayerState.Error; this.dispatchEvent(new CustomEvent(PlayerEvents.Error)); } _handleWindowBlur({ type }) { if (this.playerState === PlayerState.Playing && type === 'blur') { this._freeze(); } if (this.playerState === PlayerState.Frozen && type === 'focus') { this.play(); } } _mouseEnter() { if (this.hover && this.playerState !== PlayerState.Playing) { this.play(); } } _mouseLeave() { if (this.hover && this.playerState === PlayerState.Playing) { this.stop(); } } _onVisibilityChange() { if (document.hidden && this.playerState === PlayerState.Playing) { this._freeze(); return; } if (this.playerState === PlayerState.Frozen) { this.play(); } } _handleScroll() { if (!this.animateOnScroll || !this._lottieInstance) { return; } if (isServer()) { console.warn('DotLottie: Scroll animations might not work properly in a Server Side Rendering context. Try to wrap this in a client component.'); return; } if (this._playerState.visible) { if (this._playerState.scrollTimeout) { clearTimeout(this._playerState.scrollTimeout); } this._playerState.scrollTimeout = setTimeout(()=>{ this.playerState = PlayerState.Paused; }, 400); const adjustedScroll = scrollY > this._playerState.scrollY ? scrollY - this._playerState.scrollY : this._playerState.scrollY - scrollY, clampedScroll = Math.min(Math.max(adjustedScroll / 3, 1), this._lottieInstance.totalFrames * 3), roundedScroll = clampedScroll / 3; requestAnimationFrame(()=>{ if (roundedScroll < (this._lottieInstance?.totalFrames ?? 0)) { this.playerState = PlayerState.Playing; this._lottieInstance?.goToAndStop(roundedScroll, true); } else { this.playerState = PlayerState.Paused; } }); } } _handleSeekChange({ target }) { if (!(target instanceof HTMLInputElement) || !this._lottieInstance || isNaN(Number(target.value))) { return; } this.seek(Math.round(Number(target.value) / 100 * this._lottieInstance.totalFrames)); } _isLottie(json) { const mandatory = [ 'v', 'ip', 'op', 'layers', 'fr', 'w', 'h' ]; return mandatory.every((field)=>Object.prototype.hasOwnProperty.call(json, field)); } getLottie() { return this._lottieInstance; } async play() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } try { this._lottieInstance.play(); this.dispatchEvent(new CustomEvent(PlayerEvents.Play)); } finally{ this.playerState = PlayerState.Playing; } } pause() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } try { this._lottieInstance.pause(); this.dispatchEvent(new CustomEvent(PlayerEvents.Pause)); } finally{ this.playerState = PlayerState.Paused; } } stop() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } this._playerState.count = 0; try { this._lottieInstance.stop(); this.dispatchEvent(new CustomEvent(PlayerEvents.Stop)); } finally{ this.playerState = PlayerState.Stopped; } } destroy() { if (!this._lottieInstance) { return; } this.playerState = PlayerState.Destroyed; this._lottieInstance.destroy(); this._lottieInstance = null; this.dispatchEvent(new CustomEvent(PlayerEvents.Destroyed)); this.remove(); document.removeEventListener('visibilitychange', this._onVisibilityChange); } seek(value) { if (!this._lottieInstance) { return; } const matches = value.toString().match(/^([0-9]+)(%?)$/); if (!matches) { return; } const frame = Math.round(matches[2] === '%' ? this._lottieInstance.totalFrames * Number(matches[1]) / 100 : Number(matches[1])); this._seeker = frame; if (this.playerState === PlayerState.Playing || this.playerState === PlayerState.Frozen && this._playerState.prev === PlayerState.Playing) { this._lottieInstance.goToAndPlay(frame, true); this.playerState = PlayerState.Playing; return; } this._lottieInstance.goToAndStop(frame, true); this._lottieInstance.pause(); } snapshot() { if (!this.shadowRoot || !this.src) { return; } const svgElement = this.shadowRoot.querySelector('.animation svg'), data = svgElement instanceof Node ? new XMLSerializer().serializeToString(svgElement) : null; if (!data) { console.error('Could not serialize data'); return; } download(data, { mimeType: 'image/svg+xml', name: `${getFilename(this.src)}-${frameOutput(this._seeker)}.svg` }); return data; } setSubframe(value) { if (!this._lottieInstance) { return; } this._lottieInstance.setSubframe(value); } setCount(value) { if (!this._lottieInstance) { return; } this.count = value; } _freeze() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } try { this._lottieInstance.pause(); this.dispatchEvent(new CustomEvent(PlayerEvents.Freeze)); } finally{ this.playerState = PlayerState.Frozen; } } async reload() { if (!this._lottieInstance || !this.src) { return; } this._lottieInstance.destroy(); await this.load(this.src); } setSpeed(value = 1) { if (!this._lottieInstance) { return; } this._lottieInstance.setSpeed(value); } setDirection(value) { if (!this._lottieInstance) { return; } this._lottieInstance.setDirection(value); } setLoop(value) { if (!this._lottieInstance) { return; } this._lottieInstance.setLoop(value); } setMultiAnimationSettings(settings) { if (!this._lottieInstance) { return; } this.multiAnimationSettings = settings; } togglePlay() { if (!this._lottieInstance) { return; } const { currentFrame, playDirection, totalFrames } = this._lottieInstance; if (this.playerState === PlayerState.Playing) { return this.pause(); } if (this.playerState !== PlayerState.Completed) { return this.play(); } this.playerState = PlayerState.Playing; if (this._isBounce) { this.setDirection(playDirection * -1); return this._lottieInstance.goToAndPlay(currentFrame, true); } if (playDirection === -1) { return this._lottieInstance.goToAndPlay(totalFrames, true); } return this._lottieInstance.goToAndPlay(0, true); } toggleLoop() { const val = !this.loop; this.loop = val; this.setLoop(val); } toggleBoomerang() { const curr = this.multiAnimationSettings?.[this._currentAnimation]; if (curr?.mode !== undefined) { if (curr.mode === PlayMode.Normal) { curr.mode = PlayMode.Bounce; this._isBounce = true; return; } curr.mode = PlayMode.Normal; this._isBounce = false; return; } if (this.mode === PlayMode.Normal) { this.mode = PlayMode.Bounce; this._isBounce = true; return; } this.mode = PlayMode.Normal; this._isBounce = false; } _toggleSettings(flag) { if (flag === undefined) { this._isSettingsOpen = !this._isSettingsOpen; return; } this._isSettingsOpen = flag; } _handleBlur() { setTimeout(()=>this._toggleSettings(false), 200); } _switchInstance(isPrevious = false) { if (!this._animations[this._currentAnimation]) { return; } try { if (this._lottieInstance) { this._lottieInstance.destroy(); } this._lottieInstance = Lottie__namespace.default.loadAnimation({ ...this._getOptions(), animationData: this._animations[this._currentAnimation] }); if (this.multiAnimationSettings?.[this._currentAnimation]?.mode) { this._isBounce = this.multiAnimationSettings[this._currentAnimation].mode === PlayMode.Bounce; } this._removeEventListeners(); this._addEventListeners(); this.dispatchEvent(new CustomEvent(isPrevious ? PlayerEvents.Previous : PlayerEvents.Next)); if (this.multiAnimationSettings?.[this._currentAnimation]?.autoplay ?? this.autoplay) { if (this.animateOnScroll) { this._lottieInstance?.goToAndStop(0, true); this.playerState = PlayerState.Paused; return; } this._lottieInstance?.goToAndPlay(0, true); this.playerState = PlayerState.Playing; return; } this._lottieInstance?.goToAndStop(0, true); this.playerState = PlayerState.Stopped; } catch (err) { this._errorMessage = handleErrors(err).message; this.playerState = PlayerState.Error; this.dispatchEvent(new CustomEvent(PlayerEvents.Error)); } } next() { this._currentAnimation++; this._switchInstance(); } prev() { this._currentAnimation--; this._switchInstance(true); } static get styles() { const styleSheet = new CSSStyleSheet(); styleSheet.replace(css_248z); return styleSheet; } constructor(){ super(), this._render = renderPlayer, this._renderControls = renderControls, this.playerState = PlayerState.Loading, this._isSettingsOpen = false, this._seeker = 0, this._currentAnimation = 0, this._lottieInstance = null, this._identifier = this.id || useId('dotlottie'), this._errorMessage = 'Something went wrong', this._isBounce = false, this._playerState = { count: 0, loaded: false, prev: PlayerState.Loading, scrollTimeout: null, scrollY: 0, visible: false }, this._handleSettingsClick = ({ target })=>{ this._toggleSettings(); if (target instanceof HTMLElement) { target.focus(); } }; this._complete = this._complete.bind(this); this._dataFailed = this._dataFailed.bind(this); this._dataReady = this._dataReady.bind(this); this._DOMLoaded = this._DOMLoaded.bind(this); this._enterFrame = this._enterFrame.bind(this); this._freeze = this._freeze.bind(this); this._handleBlur = this._handleBlur.bind(this); this._handleScroll = this._handleScroll.bind(this); this._handleSeekChange = this._handleSeekChange.bind(this); this._handleWindowBlur = this._handleWindowBlur.bind(this); this._loopComplete = this._loopComplete.bind(this); this._mouseEnter = this._mouseEnter.bind(this); this._mouseLeave = this._mouseLeave.bind(this); this._onVisibilityChange = this._onVisibilityChange.bind(this); this._switchInstance = this._switchInstance.bind(this); this.togglePlay = this.togglePlay.bind(this); this.stop = this.stop.bind(this); this.prev = this.prev.bind(this); this.next = this.next.bind(this); this.snapshot = this.snapshot.bind(this); this.toggleLoop = this.toggleLoop.bind(this); this.toggleBoomerang = this.toggleBoomerang.bind(this); this.destroy = this.destroy.bind(this); this.template = document.createElement('template'); this.shadow = this.attachShadow({ mode: 'open' }); } }"
        }
      ],
      "exports": [
        {
          "kind": "custom-element-definition",
          "name": "dotlottie-player",
          "declaration": {
            "name": "DotLottiePlayer",
            "module": "dist/cjs/index.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "dist/esm/index.js",
      "declarations": [
        {
          "kind": "variable",
          "name": "PlayerState"
        },
        {
          "kind": "variable",
          "name": "PlayMode"
        },
        {
          "kind": "variable",
          "name": "PlayerEvents"
        },
        {
          "kind": "variable",
          "name": "DotLottiePlayer",
          "default": "class DotLottiePlayer extends EnhancedElement { async connectedCallback() { super.connectedCallback(); this._render(); this._container = this.shadow.querySelector('.animation'); this._renderControls(); if (typeof document.hidden !== 'undefined') { document.addEventListener('visibilitychange', this._onVisibilityChange); } this._addIntersectionObserver(); await this.load(this.src); this.dispatchEvent(new CustomEvent(PlayerEvents.Rendered)); } disconnectedCallback() { if (this._intersectionObserver) { this._intersectionObserver.disconnect(); this._intersectionObserver = undefined; } if (this._lottieInstance) { this._lottieInstance.destroy(); } document.removeEventListener('visibilitychange', this._onVisibilityChange); } static get observedAttributes() { return [ 'animateOnScroll', 'autoplay', 'controls', 'direction', 'hover', 'loop', 'mode', 'speed', 'subframe' ]; } attributeChangedCallback(name, _oldValue, value) { if (!this._lottieInstance) { return; } if (name === 'animateOnScroll') { if (value === '' || Boolean(value)) { this._lottieInstance.autoplay = false; addEventListener('scroll', this._handleScroll, { capture: true, passive: true }); return; } removeEventListener('scroll', this._handleScroll, true); } if (name === 'autoplay') { if (this.animateOnScroll) { return; } if (value === '' || Boolean(value)) { this.play(); return; } this.stop(); } if (name === 'controls') { this._renderControls(); } if (name === 'direction') { if (Number(value) === -1) { return this.setDirection(-1); } this.setDirection(1); } if (name === 'hover' && this._container) { if (value === '' || Boolean(value)) { this._container.addEventListener('mouseenter', this._mouseEnter); this._container.addEventListener('mouseleave', this._mouseLeave); return; } this._container.removeEventListener('mouseenter', this._mouseEnter); this._container.removeEventListener('mouseleave', this._mouseLeave); } if (name === 'loop') { const toggleLoop = this.shadow.querySelector('.toggleLoop'); if (toggleLoop instanceof HTMLButtonElement) { toggleLoop.dataset.active = value; } this.setLoop(value === '' || Boolean(value)); } if (name === 'mode') { const toggleBoomerang = this.shadow.querySelector('.toggleBoomerang'); if (toggleBoomerang instanceof HTMLButtonElement) { toggleBoomerang.dataset.active = (value === PlayMode.Bounce).toString(); } this._isBounce = value === PlayMode.Bounce; } if (name === 'speed') { const val = Number(value); if (val && !isNaN(val)) { this.setSpeed(val); } } if (name === 'subframe') { this.setSubframe(value === '' || Boolean(value)); } } static get observedProperties() { return [ 'playerState', '_isSettingsOpen', '_seeker', '_currentAnimation', '_animations' ]; } propertyChangedCallback(name, _oldValue, value) { if (!this.shadow) { return; } const togglePlay = this.shadow.querySelector('.togglePlay'), stop = this.shadow.querySelector('.stop'), prev = this.shadow.querySelector('.prev'), next = this.shadow.querySelector('.next'), seeker = this.shadow.querySelector('.seeker'), progress = this.shadow.querySelector('progress'), popover = this.shadow.querySelector('.popover'); if (!(togglePlay instanceof HTMLButtonElement) || !(stop instanceof HTMLButtonElement) || !(next instanceof HTMLButtonElement) || !(prev instanceof HTMLButtonElement) || !(seeker instanceof HTMLInputElement) || !(progress instanceof HTMLProgressElement)) { return; } if (name === 'playerState') { togglePlay.dataset.active = (value === PlayerState.Playing || value === PlayerState.Paused).toString(); stop.dataset.active = (value === PlayerState.Stopped).toString(); if (value === PlayerState.Playing) { togglePlay.innerHTML = `<svg width=\"24\" height=\"24\" aria-hidden=\"true\" focusable=\"false\"><path d=\"M14.016 5.016H18v13.969h-3.984V5.016zM6 18.984V5.015h3.984v13.969H6z\"/></svg>`; } else { togglePlay.innerHTML = `<svg width=\"24\" height=\"24\" aria-hidden=\"true\" focusable=\"false\"><path d=\"M8.016 5.016L18.985 12 8.016 18.984V5.015z\"/></svg>`; } } if (name === '_seeker' && typeof value === 'number') { seeker.value = value.toString(); seeker.ariaValueNow = value.toString(); progress.value = value; } if (name === '_animations' && Array.isArray(value)) { if (this._currentAnimation + 1 < value.length) { next.hidden = false; } } if (name === '_currentAnimation' && typeof value === 'number') { if (value + 1 >= this._animations.length) { next.hidden = true; } else { next.hidden = false; } if (value) { prev.hidden = false; } else { prev.hidden = true; } } if (name === '_isSettingsOpen' && typeof value === 'boolean' && popover instanceof HTMLDivElement) { popover.hidden = !value; } } set animateOnScroll(value) { this.setAttribute('animateOnScroll', (!!value).toString()); } get animateOnScroll() { const val = this.getAttribute('animateOnScroll'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set autoplay(value) { this.setAttribute('autoplay', (!!value).toString()); } get autoplay() { const val = this.getAttribute('autoplay'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set background(value) { this.setAttribute('background', value); } get background() { return this.getAttribute('background') || 'transparent'; } set controls(value) { this.setAttribute('controls', (!!value).toString()); } get controls() { const val = this.getAttribute('controls'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set count(value) { this.setAttribute('count', value.toString()); } get count() { const val = this.getAttribute('count'); if (val) { return Number(val); } return 0; } set description(value) { this.setAttribute('description', value); } get description() { return this.getAttribute('description') || ''; } set direction(value) { this.setAttribute('direction', value.toString()); } get direction() { const val = Number(this.getAttribute('')); if (val === -1) { return val; } return 1; } set hover(value) { this.setAttribute('hover', value.toString()); } get hover() { const val = this.getAttribute('hover'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set intermission(value) { this.setAttribute('intermission', value.toString()); } get intermission() { const val = Number(this.getAttribute('intermission')); if (!isNaN(val)) { return val; } return 0; } set loop(value) { this.setAttribute('loop', (!!value).toString()); } get loop() { const val = this.getAttribute('loop'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set mode(value) { this.setAttribute('mode', value.toString()); } get mode() { const val = this.getAttribute('mode'); if (val === PlayMode.Bounce) { return val; } return PlayMode.Normal; } set multiAnimationSettings(value) { this.setAttribute('multiAnimationSettings', JSON.stringify(value)); } get multiAnimationSettings() { const val = JSON.parse(this.getAttribute('multiAnimationSettings') || 'null'); if (Array.isArray(val)) { return val; } return []; } set objectfit(value) { this.setAttribute('objectfit', value); } get objectfit() { const val = this.getAttribute('objectfit'); if (val && Object.values(ObjectFit).includes(val)) { return val; } return ObjectFit.Contain; } set preserveAspectRatio(value) { this.setAttribute('preserveAspectRatio', value || PreserveAspectRatio.Contain); } get preserveAspectRatio() { const val = this.getAttribute('preserveAspectRatio'); if (val && Object.values(PreserveAspectRatio).includes(val)) { return val; } return null; } set segment(value) { this.setAttribute('segment', JSON.stringify(value)); } get segment() { const val = JSON.parse(this.getAttribute('segment') || 'null'); if (Array.isArray(val)) { return val; } return undefined; } set simple(value) { this.setAttribute('simple', value.toString()); } get simple() { const val = this.getAttribute('simple'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } set speed(value) { this.setAttribute('speed', value?.toString()); } get speed() { const val = this.getAttribute('speed'); if (val !== null && !isNaN(Number(val))) { return Number(val); } return 1; } set src(value) { this.setAttribute('src', value || ''); } get src() { return this.getAttribute('src'); } set subframe(value) { this.setAttribute('subframe', (!!value).toString()); } get subframe() { const val = this.getAttribute('subframe'); if (val === 'true' || val === '' || val === '1') { return true; } return false; } _getOptions() { if (!this._container) { throw new Error('Container not rendered'); } const preserveAspectRatio = this.preserveAspectRatio ?? (this.objectfit && aspectRatio(this.objectfit)), currentAnimationSettings = this.multiAnimationSettings?.length ? this.multiAnimationSettings?.[this._currentAnimation] : undefined, currentAnimationManifest = this._manifest.animations?.[this._currentAnimation]; let loop = !!this.loop; if (currentAnimationManifest.loop !== undefined && this.loop === undefined) { loop = !!currentAnimationManifest.loop; } if (currentAnimationSettings?.loop !== undefined) { loop = !!currentAnimationSettings.loop; } let autoplay = !!this.autoplay; if (currentAnimationManifest.autoplay !== undefined && this.autoplay === undefined) { autoplay = !!currentAnimationManifest.autoplay; } if (currentAnimationSettings?.autoplay !== undefined) { autoplay = !!currentAnimationSettings.autoplay; } if (this.animateOnScroll) { autoplay = false; } let initialSegment = this.segment; if (this.segment?.every((val)=>val > 0)) { initialSegment = [ this.segment[0] - 1, this.segment[1] - 1 ]; } if (this.segment?.some((val)=>val < 0)) { initialSegment = undefined; } const options = { autoplay, container: this._container, initialSegment, loop, renderer: 'svg', rendererSettings: { hideOnTransparent: true, imagePreserveAspectRatio: preserveAspectRatio, preserveAspectRatio, progressiveLoad: true } }; return options; } _addIntersectionObserver() { if (!this._container || this._intersectionObserver || !('IntersectionObserver' in window)) { return; } this._intersectionObserver = new IntersectionObserver((entries)=>{ for (const entry of entries){ if (!entry.isIntersecting || document.hidden) { if (this.playerState === PlayerState.Playing) { this._freeze(); } this._playerState.visible = false; continue; } if (!this.animateOnScroll && this.playerState === PlayerState.Frozen) { this.play(); } if (!this._playerState.scrollY) { this._playerState.scrollY = scrollY; } this._playerState.visible = true; } }); this._intersectionObserver.observe(this._container); } async load(src) { if (!this.shadowRoot || !src) { return; } try { const { animations, manifest } = await getAnimationData(src); if (!animations || animations.some((animation)=>!this._isLottie(animation))) { throw new Error('Broken or corrupted file'); } this._isBounce = this.mode === PlayMode.Bounce; if (this.multiAnimationSettings?.length) { if (this.multiAnimationSettings[this._currentAnimation]?.mode) { this._isBounce = this.multiAnimationSettings[this._currentAnimation].mode === PlayMode.Bounce; } } this._animations = animations; this._manifest = manifest ?? { animations: [ { autoplay: !this.animateOnScroll && this.autoplay, direction: this.direction, id: useId(), loop: this.loop, mode: this.mode, speed: this.speed } ] }; if (this._lottieInstance) { this._lottieInstance.destroy(); } this.playerState = PlayerState.Stopped; if (!this.animateOnScroll && (this.autoplay || this.multiAnimationSettings?.[this._currentAnimation]?.autoplay)) { this.playerState = PlayerState.Playing; } this._lottieInstance = Lottie.default.loadAnimation({ ...this._getOptions(), animationData: animations[this._currentAnimation] }); } catch (err) { this._errorMessage = handleErrors(err).message; this.playerState = PlayerState.Error; this.dispatchEvent(new CustomEvent(PlayerEvents.Error)); return; } this._addEventListeners(); const speed = this.multiAnimationSettings?.[this._currentAnimation]?.speed ?? this.speed ?? this._manifest.animations[this._currentAnimation].speed, direction = this.multiAnimationSettings?.[this._currentAnimation]?.direction ?? this.direction ?? this._manifest.animations[this._currentAnimation].direction ?? 1; this._lottieInstance.setSpeed(speed); this._lottieInstance.setDirection(direction); this._lottieInstance.setSubframe(!!this.subframe); if (this.autoplay || this.animateOnScroll) { if (this.direction === -1) { this.seek('99%'); } if (!('IntersectionObserver' in window)) { if (!this.animateOnScroll) { this.play(); } this._playerState.visible = true; } this._addIntersectionObserver(); } } getManifest() { return this._manifest; } _toggleEventListeners(action) { const method = action === 'add' ? 'addEventListener' : 'removeEventListener'; if (this._lottieInstance) { this._lottieInstance[method]('enterFrame', this._enterFrame); this._lottieInstance[method]('complete', this._complete); this._lottieInstance[method]('loopComplete', this._loopComplete); this._lottieInstance[method]('DOMLoaded', this._DOMLoaded); this._lottieInstance[method]('data_ready', this._dataReady); this._lottieInstance[method]('data_failed', this._dataFailed); } if (this._container && this.hover) { this._container[method]('mouseenter', this._mouseEnter); this._container[method]('mouseleave', this._mouseLeave); } window[method]('focus', this._handleWindowBlur, { capture: false, passive: true }); window[method]('blur', this._handleWindowBlur, { capture: false, passive: true }); if (this.animateOnScroll) { window[method]('scroll', this._handleScroll, { capture: true, passive: true }); } } _addEventListeners() { this._toggleEventListeners('add'); } _removeEventListeners() { this._toggleEventListeners('remove'); } _loopComplete() { if (!this._lottieInstance) { return; } const { playDirection, totalFrames } = this._lottieInstance, inPoint = this.segment ? this.segment[0] : 0, outPoint = this.segment ? this.segment[0] : totalFrames; if (this.count) { if (this._isBounce) { this._playerState.count += 0.5; } else { this._playerState.count += 1; } if (this._playerState.count >= this.count) { this.setLoop(false); this.playerState = PlayerState.Completed; this.dispatchEvent(new CustomEvent(PlayerEvents.Complete)); return; } } this.dispatchEvent(new CustomEvent(PlayerEvents.Loop)); if (this._isBounce) { this._lottieInstance.goToAndStop(playDirection === -1 ? inPoint : outPoint * 0.99, true); this._lottieInstance.setDirection(playDirection * -1); return setTimeout(()=>{ if (!this.animateOnScroll) { this._lottieInstance?.play(); } }, this.intermission); } this._lottieInstance.goToAndStop(playDirection === -1 ? outPoint * 0.99 : inPoint, true); return setTimeout(()=>{ if (!this.animateOnScroll) { this._lottieInstance?.play(); } }, this.intermission); } _enterFrame() { if (!this._lottieInstance) { return; } const { currentFrame, totalFrames } = this._lottieInstance; this._seeker = Math.round(currentFrame / totalFrames * 100); this.dispatchEvent(new CustomEvent(PlayerEvents.Frame, { detail: { frame: currentFrame, seeker: this._seeker } })); } _complete() { if (!this._lottieInstance) { return; } if (this._animations.length > 1) { if (this.multiAnimationSettings?.[this._currentAnimation + 1]?.autoplay) { return this.next(); } if (this.loop && this._currentAnimation === this._animations.length - 1) { this._currentAnimation = 0; return this._switchInstance(); } } const { currentFrame, totalFrames } = this._lottieInstance; this._seeker = Math.round(currentFrame / totalFrames * 100); this.playerState = PlayerState.Completed; this.dispatchEvent(new CustomEvent(PlayerEvents.Complete, { detail: { frame: currentFrame, seeker: this._seeker } })); } _DOMLoaded() { this._playerState.loaded = true; this.dispatchEvent(new CustomEvent(PlayerEvents.Ready)); } _dataReady() { this.dispatchEvent(new CustomEvent(PlayerEvents.Load)); } _dataFailed() { this.playerState = PlayerState.Error; this.dispatchEvent(new CustomEvent(PlayerEvents.Error)); } _handleWindowBlur({ type }) { if (this.playerState === PlayerState.Playing && type === 'blur') { this._freeze(); } if (this.playerState === PlayerState.Frozen && type === 'focus') { this.play(); } } _mouseEnter() { if (this.hover && this.playerState !== PlayerState.Playing) { this.play(); } } _mouseLeave() { if (this.hover && this.playerState === PlayerState.Playing) { this.stop(); } } _onVisibilityChange() { if (document.hidden && this.playerState === PlayerState.Playing) { this._freeze(); return; } if (this.playerState === PlayerState.Frozen) { this.play(); } } _handleScroll() { if (!this.animateOnScroll || !this._lottieInstance) { return; } if (isServer()) { console.warn('DotLottie: Scroll animations might not work properly in a Server Side Rendering context. Try to wrap this in a client component.'); return; } if (this._playerState.visible) { if (this._playerState.scrollTimeout) { clearTimeout(this._playerState.scrollTimeout); } this._playerState.scrollTimeout = setTimeout(()=>{ this.playerState = PlayerState.Paused; }, 400); const adjustedScroll = scrollY > this._playerState.scrollY ? scrollY - this._playerState.scrollY : this._playerState.scrollY - scrollY, clampedScroll = Math.min(Math.max(adjustedScroll / 3, 1), this._lottieInstance.totalFrames * 3), roundedScroll = clampedScroll / 3; requestAnimationFrame(()=>{ if (roundedScroll < (this._lottieInstance?.totalFrames ?? 0)) { this.playerState = PlayerState.Playing; this._lottieInstance?.goToAndStop(roundedScroll, true); } else { this.playerState = PlayerState.Paused; } }); } } _handleSeekChange({ target }) { if (!(target instanceof HTMLInputElement) || !this._lottieInstance || isNaN(Number(target.value))) { return; } this.seek(Math.round(Number(target.value) / 100 * this._lottieInstance.totalFrames)); } _isLottie(json) { const mandatory = [ 'v', 'ip', 'op', 'layers', 'fr', 'w', 'h' ]; return mandatory.every((field)=>Object.prototype.hasOwnProperty.call(json, field)); } getLottie() { return this._lottieInstance; } async play() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } try { this._lottieInstance.play(); this.dispatchEvent(new CustomEvent(PlayerEvents.Play)); } finally{ this.playerState = PlayerState.Playing; } } pause() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } try { this._lottieInstance.pause(); this.dispatchEvent(new CustomEvent(PlayerEvents.Pause)); } finally{ this.playerState = PlayerState.Paused; } } stop() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } this._playerState.count = 0; try { this._lottieInstance.stop(); this.dispatchEvent(new CustomEvent(PlayerEvents.Stop)); } finally{ this.playerState = PlayerState.Stopped; } } destroy() { if (!this._lottieInstance) { return; } this.playerState = PlayerState.Destroyed; this._lottieInstance.destroy(); this._lottieInstance = null; this.dispatchEvent(new CustomEvent(PlayerEvents.Destroyed)); this.remove(); document.removeEventListener('visibilitychange', this._onVisibilityChange); } seek(value) { if (!this._lottieInstance) { return; } const matches = value.toString().match(/^([0-9]+)(%?)$/); if (!matches) { return; } const frame = Math.round(matches[2] === '%' ? this._lottieInstance.totalFrames * Number(matches[1]) / 100 : Number(matches[1])); this._seeker = frame; if (this.playerState === PlayerState.Playing || this.playerState === PlayerState.Frozen && this._playerState.prev === PlayerState.Playing) { this._lottieInstance.goToAndPlay(frame, true); this.playerState = PlayerState.Playing; return; } this._lottieInstance.goToAndStop(frame, true); this._lottieInstance.pause(); } snapshot() { if (!this.shadowRoot || !this.src) { return; } const svgElement = this.shadowRoot.querySelector('.animation svg'), data = svgElement instanceof Node ? new XMLSerializer().serializeToString(svgElement) : null; if (!data) { console.error('Could not serialize data'); return; } download(data, { mimeType: 'image/svg+xml', name: `${getFilename(this.src)}-${frameOutput(this._seeker)}.svg` }); return data; } setSubframe(value) { if (!this._lottieInstance) { return; } this._lottieInstance.setSubframe(value); } setCount(value) { if (!this._lottieInstance) { return; } this.count = value; } _freeze() { if (!this._lottieInstance) { return; } if (this.playerState) { this._playerState.prev = this.playerState; } try { this._lottieInstance.pause(); this.dispatchEvent(new CustomEvent(PlayerEvents.Freeze)); } finally{ this.playerState = PlayerState.Frozen; } } async reload() { if (!this._lottieInstance || !this.src) { return; } this._lottieInstance.destroy(); await this.load(this.src); } setSpeed(value = 1) { if (!this._lottieInstance) { return; } this._lottieInstance.setSpeed(value); } setDirection(value) { if (!this._lottieInstance) { return; } this._lottieInstance.setDirection(value); } setLoop(value) { if (!this._lottieInstance) { return; } this._lottieInstance.setLoop(value); } setMultiAnimationSettings(settings) { if (!this._lottieInstance) { return; } this.multiAnimationSettings = settings; } togglePlay() { if (!this._lottieInstance) { return; } const { currentFrame, playDirection, totalFrames } = this._lottieInstance; if (this.playerState === PlayerState.Playing) { return this.pause(); } if (this.playerState !== PlayerState.Completed) { return this.play(); } this.playerState = PlayerState.Playing; if (this._isBounce) { this.setDirection(playDirection * -1); return this._lottieInstance.goToAndPlay(currentFrame, true); } if (playDirection === -1) { return this._lottieInstance.goToAndPlay(totalFrames, true); } return this._lottieInstance.goToAndPlay(0, true); } toggleLoop() { const val = !this.loop; this.loop = val; this.setLoop(val); } toggleBoomerang() { const curr = this.multiAnimationSettings?.[this._currentAnimation]; if (curr?.mode !== undefined) { if (curr.mode === PlayMode.Normal) { curr.mode = PlayMode.Bounce; this._isBounce = true; return; } curr.mode = PlayMode.Normal; this._isBounce = false; return; } if (this.mode === PlayMode.Normal) { this.mode = PlayMode.Bounce; this._isBounce = true; return; } this.mode = PlayMode.Normal; this._isBounce = false; } _toggleSettings(flag) { if (flag === undefined) { this._isSettingsOpen = !this._isSettingsOpen; return; } this._isSettingsOpen = flag; } _handleBlur() { setTimeout(()=>this._toggleSettings(false), 200); } _switchInstance(isPrevious = false) { if (!this._animations[this._currentAnimation]) { return; } try { if (this._lottieInstance) { this._lottieInstance.destroy(); } this._lottieInstance = Lottie.default.loadAnimation({ ...this._getOptions(), animationData: this._animations[this._currentAnimation] }); if (this.multiAnimationSettings?.[this._currentAnimation]?.mode) { this._isBounce = this.multiAnimationSettings[this._currentAnimation].mode === PlayMode.Bounce; } this._removeEventListeners(); this._addEventListeners(); this.dispatchEvent(new CustomEvent(isPrevious ? PlayerEvents.Previous : PlayerEvents.Next)); if (this.multiAnimationSettings?.[this._currentAnimation]?.autoplay ?? this.autoplay) { if (this.animateOnScroll) { this._lottieInstance?.goToAndStop(0, true); this.playerState = PlayerState.Paused; return; } this._lottieInstance?.goToAndPlay(0, true); this.playerState = PlayerState.Playing; return; } this._lottieInstance?.goToAndStop(0, true); this.playerState = PlayerState.Stopped; } catch (err) { this._errorMessage = handleErrors(err).message; this.playerState = PlayerState.Error; this.dispatchEvent(new CustomEvent(PlayerEvents.Error)); } } next() { this._currentAnimation++; this._switchInstance(); } prev() { this._currentAnimation--; this._switchInstance(true); } static get styles() { const styleSheet = new CSSStyleSheet(); styleSheet.replace(css_248z); return styleSheet; } constructor(){ super(), this._render = renderPlayer, this._renderControls = renderControls, this.playerState = PlayerState.Loading, this._isSettingsOpen = false, this._seeker = 0, this._currentAnimation = 0, this._lottieInstance = null, this._identifier = this.id || useId('dotlottie'), this._errorMessage = 'Something went wrong', this._isBounce = false, this._playerState = { count: 0, loaded: false, prev: PlayerState.Loading, scrollTimeout: null, scrollY: 0, visible: false }, this._handleSettingsClick = ({ target })=>{ this._toggleSettings(); if (target instanceof HTMLElement) { target.focus(); } }; this._complete = this._complete.bind(this); this._dataFailed = this._dataFailed.bind(this); this._dataReady = this._dataReady.bind(this); this._DOMLoaded = this._DOMLoaded.bind(this); this._enterFrame = this._enterFrame.bind(this); this._freeze = this._freeze.bind(this); this._handleBlur = this._handleBlur.bind(this); this._handleScroll = this._handleScroll.bind(this); this._handleSeekChange = this._handleSeekChange.bind(this); this._handleWindowBlur = this._handleWindowBlur.bind(this); this._loopComplete = this._loopComplete.bind(this); this._mouseEnter = this._mouseEnter.bind(this); this._mouseLeave = this._mouseLeave.bind(this); this._onVisibilityChange = this._onVisibilityChange.bind(this); this._switchInstance = this._switchInstance.bind(this); this.togglePlay = this.togglePlay.bind(this); this.stop = this.stop.bind(this); this.prev = this.prev.bind(this); this.next = this.next.bind(this); this.snapshot = this.snapshot.bind(this); this.toggleLoop = this.toggleLoop.bind(this); this.toggleBoomerang = this.toggleBoomerang.bind(this); this.destroy = this.destroy.bind(this); this.template = document.createElement('template'); this.shadow = this.attachShadow({ mode: 'open' }); } }"
        },
        {
          "kind": "variable",
          "name": "tagName",
          "type": {
            "text": "string"
          },
          "default": "'dotlottie-player'"
        }
      ],
      "exports": [
        {
          "kind": "custom-element-definition",
          "name": "dotlottie-player",
          "declaration": {
            "name": "DotLottiePlayer",
            "module": "dist/esm/index.js"
          }
        },
        {
          "kind": "js",
          "name": "PlayMode",
          "declaration": {
            "name": "PlayMode",
            "module": "dist/esm/index.js"
          }
        },
        {
          "kind": "js",
          "name": "PlayerEvents",
          "declaration": {
            "name": "PlayerEvents",
            "module": "dist/esm/index.js"
          }
        },
        {
          "kind": "js",
          "name": "PlayerState",
          "declaration": {
            "name": "PlayerState",
            "module": "dist/esm/index.js"
          }
        },
        {
          "kind": "js",
          "name": "default",
          "declaration": {
            "name": "DotLottiePlayer",
            "module": "dist/esm/index.js"
          }
        },
        {
          "kind": "js",
          "name": "tagName",
          "declaration": {
            "name": "tagName",
            "module": "dist/esm/index.js"
          }
        }
      ]
    }
  ]
}
